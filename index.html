<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Blockworld</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB; /* Blue Sky Background */
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .ui-layer { position: absolute; width: 100%; height: 100%; z-index: 10; pointer-events: none; }

        /* UI Elements */
        #btn-fullscreen {
            position: absolute; top: 20px; right: 20px; width: 50px; height: 45px;
            background-color: #56ae57; border: 3px solid #000000; 
            display: flex; justify-content: center; align-items: center;
            color: white; font-size: 30px; line-height: 1;
            pointer-events: auto; cursor: pointer;
        }
        #btn-fullscreen:active { background-color: #3e8e40; transform: scale(0.95); }

        #joystick-zone {
            position: absolute; 
            bottom: max(40px, env(safe-area-inset-bottom) + 20px); 
            left: max(40px, env(safe-area-inset-left) + 20px);
            width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: auto; backdrop-filter: blur(2px);
        }
        #joystick-knob {
            position: absolute; top: 50%; left: 50%;
            width: 50px; height: 50px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
        }
        #btn-jump {
            position: absolute; 
            bottom: max(60px, env(safe-area-inset-bottom) + 40px); 
            right: max(40px, env(safe-area-inset-right) + 20px);
            width: 80px; height: 80px;
            border-radius: 50%;
            background: rgba(255, 200, 0, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.4);
            pointer-events: auto; backdrop-filter: blur(2px);
        }
        #btn-jump:active { background: rgba(255, 200, 0, 0.7); transform: scale(0.95); }

        #touch-zone {
            position: absolute; top: 0; left: 50%; width: 50%; height: 100%;
            z-index: 5; pointer-events: auto;
        }
    </style>
</head>
<body oncontextmenu="return false;">

    <div id="game-container"></div>
    <div class="ui-layer">
        <div id="btn-fullscreen">â›¶</div>
        <div id="joystick-zone"><div id="joystick-knob"></div></div>
        <div class="control-btn" id="btn-jump"></div>
        <div id="touch-zone"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- CONFIGURATION ---
        const ISLAND_RADIUS = 90; 
        const CHUNK_SIZE = 30;     
        const CAMERA_FOV = 75;
        
        // --- PHYSICS ---
        const PLAYER_HEIGHT = 1.7; 
        const PLAYER_RADIUS = 0.35; 
        const WALK_SPEED = 6.0; 
        const JUMP_VELOCITY = 9.0; 
        const GRAVITY = 28.0;   
        const PHYSICS_STEPS = 3; 

        // --- SETUP ---
        const container = document.getElementById('game-container');
        const scene = new THREE.Scene();
        
        // SKY COLOR SETTINGS
        const SKY_COLOR = 0x87CEEB; // Classic Sky Blue
        scene.background = new THREE.Color(SKY_COLOR);
        // Fog pushed back (30 to 80) so the sky looks blue, not gray, near the player
        scene.fog = new THREE.Fog(SKY_COLOR, 30, 80);

        const clock = new THREE.Clock();
        const camera = new THREE.PerspectiveCamera(CAMERA_FOV, window.innerWidth / window.innerHeight, 0.5, 120);
        
        const player = { x: 0, y: 15, z: 0, vx: 0, vy: 0, vz: 0, yaw: 0, pitch: 0, onGround: false };

        const renderer = new THREE.WebGLRenderer({ 
            antialias: false, 
            powerPreference: "high-performance",
            precision: "highp", 
            depth: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.0));
        renderer.outputEncoding = THREE.sRGBEncoding;
        
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFShadowMap; 
        renderer.shadowMap.autoUpdate = true;
        
        container.appendChild(renderer.domElement);

        // --- FULLSCREEN ---
        document.getElementById('btn-fullscreen').addEventListener('click', (e) => {
            e.stopPropagation();
            if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(()=>{});
            else if (document.exitFullscreen) document.exitFullscreen();
        });

        // --- LIGHTING ---
        const hemiLight = new THREE.HemisphereLight(SKY_COLOR, 0x444444, 0.8);
        hemiLight.position.set(0, 50, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffe0, 1.1);
        dirLight.position.set(30, 80, 20); 
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024; dirLight.shadow.mapSize.height = 1024;
        const d = 40; 
        dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
        dirLight.shadow.bias = -0.0005; 
        scene.add(dirLight);

        // --- BAREBONES TEXTURES ---
        function createBarebonesTexture(colorHex) {
            const canvas = document.createElement('canvas');
            canvas.width = 16; canvas.height = 16;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = colorHex;
            ctx.fillRect(0, 0, 16, 16);

            // Subtle border
            ctx.strokeStyle = 'rgba(0,0,0,0.1)'; 
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, 16, 16);

            const tex = new THREE.CanvasTexture(canvas);
            tex.generateMipmaps = false; 
            tex.magFilter = THREE.NearestFilter;
            tex.minFilter = THREE.NearestFilter;
            tex.encoding = THREE.sRGBEncoding;
            return tex;
        }

        const mats = {
            grass: new THREE.MeshLambertMaterial({ map: createBarebonesTexture('#5EBD3E') }), 
            wood:  new THREE.MeshLambertMaterial({ map: createBarebonesTexture('#876846') }), 
            leaf:  new THREE.MeshLambertMaterial({ map: createBarebonesTexture('#4FA332') })  
        };

        // --- WORLD GEN ---
        const worldBlocks = new Map();
        function setBlockData(x, y, z, type) { worldBlocks.set(`${x},${y},${z}`, type); }
        function hasBlock(x, y, z) { return worldBlocks.has(`${x},${y},${z}`); }

        const treePositions = [];
        let startHeight = 0;
        console.log("Generating Map...");
        
        for (let x = -ISLAND_RADIUS; x <= ISLAND_RADIUS; x++) {
            for (let z = -ISLAND_RADIUS; z <= ISLAND_RADIUS; z++) {
                const dist = Math.sqrt(x*x + z*z);
                if (dist > ISLAND_RADIUS) continue;
                
                let height = Math.sin(x * 0.1) * 3 + Math.cos(z * 0.1) * 3;
                height += Math.sin(x * 0.03 + z * 0.03) * 6;
                height = Math.floor(height);
                if (x === 0 && z === 0) startHeight = height;

                setBlockData(x, height, z, 'grass');

                if (Math.abs(x) > 3 || Math.abs(z) > 3) {
                    if (Math.random() < 0.02) { 
                        let tooClose = false;
                        for (let t of treePositions) {
                            if (Math.sqrt((x-t.x)**2 + (z-t.z)**2) < 9) { tooClose = true; break; }
                        }
                        if (!tooClose) {
                            generateTreeData(x, height + 1, z);
                            treePositions.push({x: x, z: z});
                        }
                    }
                }
            }
        }
        player.y = startHeight + 10;

        function generateTreeData(x, y, z) {
            const height = Math.floor(Math.random() * 2) + 3;
            for(let i=0; i<height; i++) setBlockData(x, y + i, z, 'wood');
            const leafStart = y + height - 2;
            for(let lx = -2; lx <= 2; lx++){
                for(let lz = -2; lz <= 2; lz++){
                    for(let ly = leafStart; ly <= leafStart + 1; ly++){
                        if (Math.abs(lx) === 2 && Math.abs(lz) === 2 && Math.random() > 0.5) continue;
                        if (lx === 0 && lz === 0) continue;
                        setBlockData(x + lx, ly, z + lz, 'leaf');
                    }
                }
            }
            setBlockData(x, leafStart + 2, z, 'leaf');
            setBlockData(x, leafStart + 2, z+1, 'leaf');
            setBlockData(x, leafStart + 2, z-1, 'leaf');
            setBlockData(x+1, leafStart + 2, z, 'leaf');
            setBlockData(x-1, leafStart + 2, z, 'leaf');
            setBlockData(x, leafStart + 3, z, 'leaf');
        }

        // --- MESH BUILDING ---
        console.log("Building Meshes...");
        const chunkMap = {}; 
        const dummy = new THREE.Object3D();
        const boxGeo = new THREE.BoxGeometry(1,1,1);

        worldBlocks.forEach((type, key) => {
            const parts = key.split(',');
            const x = parseInt(parts[0]);
            const y = parseInt(parts[1]);
            const z = parseInt(parts[2]);

            // Culling
            const hidden = hasBlock(x+1, y, z) && hasBlock(x-1, y, z) &&
                           hasBlock(x, y+1, z) && hasBlock(x, y-1, z) &&
                           hasBlock(x, y, z+1) && hasBlock(x, y, z-1);
            if (hidden) return;

            const cx = Math.floor(x / CHUNK_SIZE);
            const cz = Math.floor(z / CHUNK_SIZE);
            const chunkKey = `${cx},${cz}`;

            if (!chunkMap[chunkKey]) chunkMap[chunkKey] = { grass: [], wood: [], leaf: [] };
            dummy.position.set(x, y, z);
            dummy.updateMatrix();
            chunkMap[chunkKey][type].push(dummy.matrix.clone());
        });

        Object.keys(chunkMap).forEach(key => {
            const chunkData = chunkMap[key];
            ['grass', 'wood', 'leaf'].forEach(type => {
                const matrices = chunkData[type];
                if (matrices.length === 0) return;
                const mesh = new THREE.InstancedMesh(boxGeo, mats[type], matrices.length);
                for (let i = 0; i < matrices.length; i++) mesh.setMatrixAt(i, matrices[i]);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.instanceMatrix.needsUpdate = true;
                mesh.matrixAutoUpdate = false;
                scene.add(mesh);
            });
        });

        // --- CONTROLS ---
        const joystick = { x: 0, y: 0, active: false };
        const joyZone = document.getElementById('joystick-zone');
        const joyKnob = document.getElementById('joystick-knob');
        const joyRadius = 60; 
        let joyTouchId = null;

        joyZone.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            joyTouchId = touch.identifier;
            joystick.active = true;
            updateJoystick(touch);
        }, { passive: false });

        joyZone.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!joystick.active) return;
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === joyTouchId) {
                    updateJoystick(e.changedTouches[i]);
                    break;
                }
            }
        }, { passive: false });

        function resetJoystick() {
            joystick.active = false; joystick.x = 0; joystick.y = 0;
            joyKnob.style.transform = `translate(-50%, -50%)`;
            joyTouchId = null;
        }
        joyZone.addEventListener('touchend', resetJoystick);
        joyZone.addEventListener('touchcancel', resetJoystick);

        function updateJoystick(touch) {
            const rect = joyZone.getBoundingClientRect();
            let dx = touch.clientX - (rect.left + rect.width / 2);
            let dy = touch.clientY - (rect.top + rect.height / 2);
            const dist = Math.sqrt(dx*dx + dy*dy);
            const maxDist = joyRadius - 25;
            if (dist > maxDist) { dx = (dx/dist)*maxDist; dy = (dy/dist)*maxDist; }
            joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            joystick.x = dx / maxDist; joystick.y = -(dy / maxDist); 
        }

        let jumpPressed = false;
        const jumpBtn = document.getElementById('btn-jump');
        jumpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); jumpPressed = true; });
        jumpBtn.addEventListener('touchend', (e) => { e.preventDefault(); jumpPressed = false; });

        let lastLookX = 0, lastLookY = 0;
        const touchZone = document.getElementById('touch-zone');
        let camTouchId = null;

        touchZone.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (camTouchId === null) {
                const t = e.changedTouches[0];
                camTouchId = t.identifier;
                lastLookX = t.clientX; lastLookY = t.clientY;
            }
        }, { passive: false });

        touchZone.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === camTouchId) {
                    const t = e.changedTouches[i];
                    const dx = t.clientX - lastLookX;
                    const dy = t.clientY - lastLookY;
                    player.yaw -= dx * 0.005;
                    player.pitch -= dy * 0.005;
                    player.pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, player.pitch));
                    lastLookX = t.clientX; lastLookY = t.clientY;
                    break;
                }
            }
        }, { passive: false });

        const endCamera = (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === camTouchId) { camTouchId = null; break; }
            }
        };
        touchZone.addEventListener('touchend', endCamera);

        const keys = {};
        document.addEventListener('keydown', (e) => { keys[e.code] = true; if(e.code==='Space') jumpPressed=true; });
        document.addEventListener('keyup', (e) => { keys[e.code] = false; if(e.code==='Space') jumpPressed=false; });

        container.addEventListener('mousedown', () => { container.requestPointerLock(); });
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === container) {
                player.yaw -= e.movementX * 0.002;
                player.pitch -= e.movementY * 0.002;
                player.pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, player.pitch));
            }
        });

        // --- PHYSICS ---
        function checkCollision(px, py, pz) {
            const minX = Math.round(px - PLAYER_RADIUS); const maxX = Math.round(px + PLAYER_RADIUS);
            const minZ = Math.round(pz - PLAYER_RADIUS); const maxZ = Math.round(pz + PLAYER_RADIUS);
            const minY = Math.round(py); const maxY = Math.round(py + PLAYER_HEIGHT - 0.1); 
            for (let x = minX; x <= maxX; x++) {
                for (let z = minZ; z <= maxZ; z++) {
                    for (let y = minY; y <= maxY; y++) {
                        if (worldBlocks.has(`${x},${y},${z}`)) return x + "," + y + "," + z;
                    }
                }
            }
            return null;
        }

        function stepPhysics(dt) {
            let moveX = 0, moveZ = 0;
            let inputX = joystick.x, inputY = joystick.y;
            if (keys['KeyW']) inputY = 1; if (keys['KeyS']) inputY = -1;
            if (keys['KeyA']) inputX = -1; if (keys['KeyD']) inputX = 1;

            if (joystick.active || inputX !== 0 || inputY !== 0) {
                moveX += -Math.sin(player.yaw) * inputY;
                moveZ += -Math.cos(player.yaw) * inputY;
                moveX += Math.cos(player.yaw) * inputX;
                moveZ += -Math.sin(player.yaw) * inputX;
            }
            const len = Math.sqrt(moveX*moveX + moveZ*moveZ);
            if (len > 1) { moveX /= len; moveZ /= len; }
            moveX *= WALK_SPEED * dt; moveZ *= WALK_SPEED * dt;

            if (!checkCollision(player.x + moveX, player.y, player.z)) player.x += moveX;
            if (!checkCollision(player.x, player.y, player.z + moveZ)) player.z += moveZ;

            player.vy -= GRAVITY * dt;
            const nextY = player.y + (player.vy * dt);

            if (player.vy < 0) {
                const hit = checkCollision(player.x, nextY, player.z);
                if (hit) { player.y = parseInt(hit.split(',')[1]) + 0.5; player.vy = 0; player.onGround = true; } 
                else { player.y = nextY; player.onGround = false; }
            } else if (player.vy > 0) {
                const hit = checkCollision(player.x, nextY, player.z);
                if (hit) { player.y = (parseInt(hit.split(',')[1]) - 0.5) - PLAYER_HEIGHT - 0.01; player.vy = 0; } 
                else { player.y = nextY; player.onGround = false; }
            }
            if (player.y < -30) { player.x=0; player.z=0; player.y=35; player.vy=0; }
        }

        function update() {
            let dt = Math.min(clock.getDelta(), 0.1);
            if (jumpPressed && player.onGround) { player.vy = JUMP_VELOCITY; player.onGround = false; }
            const stepDt = dt / PHYSICS_STEPS;
            for(let i = 0; i < PHYSICS_STEPS; i++) stepPhysics(stepDt);
            
            camera.position.set(player.x, player.y + 1.6, player.z);
            camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');
            
            // Light Optimization
            dirLight.position.x = player.x + 30; dirLight.position.z = player.z + 20;
            dirLight.target.position.set(player.x, player.y, player.z);
            dirLight.target.updateMatrixWorld();

            renderer.render(scene, camera);
            requestAnimationFrame(update);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        update();
    </script>
</body>
</html>